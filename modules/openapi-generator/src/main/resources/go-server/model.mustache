{{>partial_header}}
package {{packageName}}

import (
    "reflect"
)

{{#models}}{{#imports}}
{{#-first}}import (
{{/-first}}	"{{import}}"{{#-last}}
)
{{/-last}}{{/imports}}

{{#model}}{{#isEnum}}{{#description}}// {{{classname}}} : {{{description}}}{{/description}}
type {{{classname}}} {{^format}}{{dataType}}{{/format}}{{{format}}}

// List of {{{classname}}}
const (
	{{#allowableValues}}
	{{#enumVars}}
	{{#enumClassPrefix}}{{{classname.toUpperCase}}}_{{/enumClassPrefix}}{{name}} {{{classname}}} = {{{value}}}
	{{/enumVars}}
	{{/allowableValues}}
)

// Allowed{{{classname}}}EnumValues is all the allowed values of {{{classname}}} enum
var Allowed{{{classname}}}EnumValues = []{{{classname}}}{
	{{#allowableValues}}
	{{#enumVars}}
	{{{value}}},
	{{/enumVars}}
	{{/allowableValues}}
}

// valid{{{classname}}}EnumValue provides a map of {{classname}}s for fast verification of use input
var valid{{{classname}}}EnumValues = map[{{{classname}}}]struct{}{
	{{#allowableValues}}
	{{#enumVars}}
	{{{value}}}: {},
	{{/enumVars}}
	{{/allowableValues}}
}

// IsValid return true if the value is valid for the enum, false otherwise
func (v {{{classname}}}) IsValid() bool {
	_, ok := valid{{{classname}}}EnumValues[v]
	return ok
}

// New{{{classname}}}FromValue returns a pointer to a valid {{{classname}}}
// for the value passed as argument, or an error if the value passed is not allowed by the enum
func New{{{classname}}}FromValue(v {{{format}}}{{^format}}{{dataType}}{{/format}}) ({{{classname}}}, error) {
	ev := {{{classname}}}(v)
	if ev.IsValid() {
		return ev, nil
	} else {
		return "", fmt.Errorf("invalid value '%v' for {{{classname}}}: valid values are %v", v, Allowed{{{classname}}}EnumValues)
	}
}

{{/isEnum}}{{^isEnum}}{{#description}}
// {{classname}} - {{{description}}}{{/description}}
type {{classname}} struct {
{{#parent}}
{{^isMap}}
{{^isArray}}
	{{{parent}}}
{{/isArray}}
{{/isMap}}
{{#isArray}}
	Items {{{parent}}}
{{/isArray}}
{{/parent}}
{{#vars}}{{#description}}
	// {{{.}}}{{/description}}
	{{#deprecated}}
	// Deprecated
	{{/deprecated}}
	{{name}} {{#isNullable}}*{{/isNullable}}{{{dataType}}} `json:"{{baseName}}{{^required}},omitempty{{/required}}"{{#vendorExtensions.x-go-custom-tag}} {{{.}}}{{/vendorExtensions.x-go-custom-tag}}`
{{/vars}}
}{{/isEnum}}

func Assert{{classname}}RequiredFields(data any) error {
    if(reflect.ValueOf(data).Kind() != reflect.Map) {
        return &RequiredError{Field: ""}
    }
    decodedMap := data.(map[string]any)


{{#vars}}
    // Checking for field `{{baseName}}`, which is {{^required}}not {{/required}}required and {{^isNullable}}non-{{/isNullable}}nullable
	if val, ok := decodedMap["{{baseName}}"]; ok {
        {{^isNullable}}
        if val == nil {
            // If null return error
            return &RequiredError{Field: "{{baseName}}"}
        }
        {{/isNullable}}
        {{#isModel}}
        // Check if it is a valid `{{dataType}}`
        if err := Assert{{dataType}}RequiredFields(val); err != nil {
            return err
        }
        {{/isModel}}
        {{#isArray}}
        // Check if json value is an array
        if(reflect.ValueOf(data).Kind() != reflect.Array) {
            return &RequiredError{Field: ""}
        }
        array := val.([]any)
        for _, item := range array {
            if item != nil {
                {{#items.isModel}}
                // Check if item is a valid `{{dataType}}`
                err := Assert{{items.dataType}}RequiredFields(item)
                if err != nil {
                    return err
                }
                {{/items.isModel}}
            }{{^items.isNullable}} else {
                // If item is null then return error
                return &RequiredError{Field: "{{classname}}.{{baseName}}[]"}
            }{{/items.isNullable}}
        }
        {{/isArray}}
    }{{#required}} else {
        // Return error since `{{baseName}}` is a required field
        return &RequiredError{Field: "{{baseName}}"}
    }{{/required}}


{{/vars}}
    return nil
}

// Assert{{classname}}Constraints checks if the values respects the defined constraints
func Assert{{classname}}Constraints(obj {{classname}}) error {
{{#Vars}}
{{#minimum}}
	if {{#isNullable}}obj.{{name}} != nil && *{{/isNullable}}obj.{{name}} < {{minimum}} {
		return &ParsingError{Err: errors.New(errMsgMinValueConstraint)}
	}
{{/minimum}}
{{#maximum}}
	if {{#isNullable}}obj.{{name}} != nil && *{{/isNullable}}obj.{{name}} > {{maximum}} {
		return &ParsingError{Err: errors.New(errMsgMaxValueConstraint)}
	}
{{/maximum}}
{{/Vars}}
	return nil
}{{/model}}{{/models}}
